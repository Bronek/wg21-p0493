---
title: Atomic minimum/maximum
document: P0493R2
date: 2021-12-02
audience:
  - WG21 SG21 (Contracts)
author:
  - name: Al Grant
    email: <al.grant@arm.com>
  - name: Bronek Kozicki
    email: <brok@spamcop.net>
  - name: Tim Northover
    email: <tnorthover@apple.com>
toc: true
toc-depth: 1
---


# Abstract

Add integer *max* and *min* operations to the set of operations supported in `<atomic>`. There are minor adjustments
to function naming necessitated by the fact that `max` and `min` do not exist as infix operators.  Also, in contrast
to the existing atomic operations (and previous versions of this proposal), it is unspecified whether a write occurs
if the new value is the same as the old value


# Changelog

## R1 to R2

Published 2021-05-11

- Change proposal to make the store unspecified if the value does not change
- Align with C++20

## R0 to R1

Published 2020-05-08

- Add motivation for defining new atomics as read-modify-write
- Clarify status of proposal for new-value-returning operations.
- Align with C++17.


## R0 

Published 2016-11-08

* Original proposal


# Introduction

This proposal extends the atomic operations library to add atomic maximum/minimum operations. These were originally proposed
for C++ in [@N3696] as particular cases of a general "priority update" mechanism, which atomically combined reading an
object's value, computing a new value and conditionally writing this value if it differs from the old value.
In contrast to [@N3696], we propose atomic maximum/minimum operations where it is unspecified whether or not the store takes
place if the new value happens to be the same as the old value. A future proposal may reintroduce the concept of a
conditionalized atomic update.

This paper benefited from discussion with Mario Torrecillas Rodriguez, Nigel Stephens and Nick Maclaren, and updates
have benefited from discussion in the SG1 Concurrency group.


# Background and motivation

Atomic addition (_fetch-and-add_) was introduced in the NYU Ultracomputer [@Gottlieb], has been implemented in a variety
of hardware architectures, and has been standardized in C and C++. Atomic maximum/minimum operations (_fetch-and-max_ ,
_fetch-and-min_) have a history almost as long as atomic addition, e.g. see [@Lipovski], and have also been implemented
in various hardware architectures but are not currently standard in C and C++. This proposal fills the gap.

Atomic maximum/minimum operations are useful in a variety of situations in multithreaded applications:

- optimal implementation of lock-free shared data structures - as in the motivating example later in this paper
- reductions in data-parallel applications: for example,
  [OpenMP](https://computing.llnl.gov/tutorials/openMP/#REDUCTION/minimum) supports maximum as a reduction operation
- recording the maximum so far reached in an optimization process, to allow unproductive threads to terminate
- collecting statistics, such as the largest item of input encountered by any worker thread.

Atomic maximum/minimum operations already exist in several other programming environments, including
[OpenCL](https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf), and in some hardware implementations. Application
need, and availability, motivate providing these operations in C++.

The proposed language changes add atomic max/min to `<atomic>`, with some syntatic adjustment due to the fact that C++
has no infix operators for max/min, and with a slight difference in semantics as described below.

The existing atomic operations (e.g. `fetch_and`) have the effect of a read-modify-write, irrespective of whether the value
changes. This is how atomic max/min are defined in several APIs (OpenCL, CUDA, C++AMP, HCC) and in several hardware
architectures (ARM, RISC-V). However, some hardware (POWER) implements atomic max/min as an atomic read-and-conditional-store.
For performance and portability, to allow efficient implementation on a variety of architectures, this proposal leaves it
unspecified whether the store happens if the new value is the same as the old value. That is, the proposed C++ atomic max/min
functions can be implemented using atomic max/min hardware operations where the store always happens in such a situation,
where it never happens, or where the hardware itself leaves it unspecified.

Hardware which implements these operations as read-and-conditional-write may offer a performance advantage at the cost of
possible correctness, where the following instruction makes an assumption as to the write half-barrier (i.e. "release"
semantics) of the preceding "min" or "max" operation. Similarly, platforms where these operations are read-modify-always-write
may sacrifice performance where there is no actual change in value, but make it easier to write correct code, where the
following instruction can take for granted the "release" semantics of the preceding "min" or "max" operation. Portable and
correct code may have to introduce an additional write barrier in case the value did not change, but such a barrier might
penalize performance on platforms where these operations are guaranteed read-modify-write since the write will have implemented
the requested semantics.This could be made easier by an addition of a predefined macro which would be always set to e.g.
1 on platforms where an additional section like this is needed, e.g. `__cpp_lib_atomic_maxmin_always_writes` (and 0 otherwise)
**We ask for feedback** as to whether or not such macro is needed.


# Summary of proposed additions to `<atomic>`

The current `<atomic>` provides atomic operations in several ways:

- as a named non-member function template e.g. `atomic_fetch_add` returning the old value
- as a named member function template e.g. `atomic<T>::fetch_add()` returning the old value
- as an overloaded compound operator e.g. `atomic<T>::operator+=()` returning the new value

Adding 'max' and 'min' versions of the named functions is straightforward. Unlike the existing atomics, max/min operations exist
in signed and unsigned flavors. The atomic type determines the operation. There is precedent for this in C, where all compound
assignments on atomic variables are defined to be atomic, including sign-sensitive operations such as divide and right-shift.

The overloaded operator `atomic<T>::operator op=(n)` is defined to return the new value of the atomic object. This does not
correspond directly to a named function. For max and min, we have no infix operators to overload. So if we want a function that
returns the new value we would need to provide it as a named function. However, for all operators the new value can be obtained
as `fetch_op(n) op n`, (the standard defines the compound operator overloads  this way) while the reverse is not true for
non-invertible operators like 'and' or 'max'. Thus the functions would add no significant functionality other than providing
one-to-one equivalents to `<atomic>` existing compound operator overloads. Following some of the early literature on atomic
operations ([@Kruskal] citing [@Draughon]), we suggest that if required, names should have the form ` replace_op`. The current
revision of this paper demonstrates what the `replace_min` and `replace_max` functions would look like; **we ask for feedback**
whether or not these should be removed; in case these are to be left in, **we ask for feedback** whether or not to add additional
overloads taking memory ordering parameter. We must stress that any inconsistency with the existing atomic functions is based
on the lack of infix representation of these operations in the language syntax, rather than because of any difference in the
nature of the operations in the language execution model.

This paper proposes operations on integral and pointer types only. If both this proposal and floating-point atomics as proposed
in [@P0020] are adopted then we propose that atomic floating-point maximum/minimum operations also be defined, in the obvious way.



# Changes to the C++ standard

The following text outlines the proposed changes, based on [@N4868].

**31: Atomic operations library [atomics]**

**31.2: Header <atomic> synopsis [atomics.syn]**

_Add:_

```cpp
namespace std {
  // 31.9, non-member functions
  ...
  template<class T>
    T atomic_fetch_max(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_max(atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_max_explicit(volatile atomic<T>*, typename atomic<T>::value_type, memory_order) noexcept;
  template<class T>
    T atomic_fetch_max_explicit(atomic<T>*, typename atomic<T>::value_type, memory_order) noexcept;
  template<class T>
    T atomic_fetch_min(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_min(atomic<T>*, typename atomic<T>::value_type) noexcept;
  template<class T>
    T atomic_fetch_min_explicit(volatile atomic<T>*, typename atomic<T>::value_type, memory_order) noexcept;
  template<class T>
    T atomic_fetch_min_explicit(atomic<T>*, typename atomic<T>::value_type, memory_order) noexcept;
  ...
}
```

**31.7.3: Specializations for integral types [atomics.ref.int]**

_Add:_

```cpp
namespace std {
  template <> struct atomic_ref<integral> {
    ...
    integral fetch_max(integral, memory_order = memory_order_seq_cst) const noexcept;
    integral fetch_min(integral, memory_order = memory_order_seq_cst) const noexcept;
    ...
    integral replace_max(integral) const noexcept;
    integral replace_min(integral) const noexcept;
  };
}
```

_Change:_

  Effects: ... These operations are atomic read-modify-write operations (6.9.2.2)

_to:_

  Effects: ...Except for `fetch_max` and `fetch_min`, these operations are atomic read-modify-write operations (6.9.2.2). For `fetch_max` and `fetch_min`, if the new value is the same as the existing value, it is unspecified whether or not the new value is written; if it is written, the effect is of a read-modify-write operation.

_Change:_

  Remarks: For signed integer types, the result is as if the object value and parameters were converted to their corresponding unsigned types, the computation performed on those types, and the result converted back to the signed type.

_to:_

  Remarks: Except for `fetch_max` and `fetch_min`, for signed integer types, the result is as if the object value and parameters were converted to their corresponding unsigned types, the computation performed on those types, and the result converted back to the signed type. For `fetch_max` and `fetch_min`, the computation is performed according to the integral type of the atomic object.


_Add the following text:_

  `integral A::replace_`_key_`(integral operand) const noexcept;`

  Requires: These operations are only defined for keys `max` and `min`.

  Effects: `A::fetch_`_key_`(operand)`

  Returns: `std::`_key_`(A::fetch_`_key_`(operand), operand)`

_After `integral operatorop=(integral operand) const noexcept;` add:_

  These operations are not defined for keys `max` and `min`.

**31.7.5: Partial specialization for pointers [atomics.ref.pointer]**

```cpp
namespace std {
  template <class T> struct atomic_ref<T *> {
    ...
    T* fetch_max(T *, memory_order = memory_order::seq_cst) const noexcept;
    T* fetch_min(T *, memory_order = memory_order::seq_cst) const noexcept;
  };
}
```

_Change:_

  Effects: ... These operations are atomic read-modify-write operations (6.9.2.2)

_to:_

  Effects: ... Except for `fetch_max` and `fetch_min`, these operations are atomic read-modify-write operations (6.9.2.2). For `fetch_max` and `fetch_min`, if the new value is the same as the existing value, it isunspecified whether or not the new value is written; if it is written, the effect is of a read-modify-write operation.

_Add the following text:_

  `T* A::replace_`_key_`(T* operand) const noexcept;

  Requires: These operations are only defined for keys `max` and `min`.

  Effects: `A::fetch_`_key_`(operand)`

  Returns: `std::`_key_`(A::fetch_`_key_`(operand), operand)`

**31.8.3: Specializations for integers [atomics.types.int]**

```cpp
namespace std {
  template <> struct atomic<integral> {
    ...
    integral fetch_max(integral, memory_order = memory_order_seq_cst) volatile noexcept;
    integral fetch_max(integral, memory_order = memory_order_seq_cst) noexcept;
    integral fetch_min(integral, memory_order = memory_order_seq_cst) volatile noexcept;
    integral fetch_min(integral, memory_order = memory_order_seq_cst) noexcept;
    ...
  };
}
```

_In table 144, [tab:atomic.types.int.comp], add the following entries:_

  | Key | Op | Computation |
  |:---:|:--:|:------------|
  | max |    | maximum as computed by |
  |     |    |`std::max` from `<algorithm>` |
  | min |    | minimum as computed by
  |     |    | `std::min` from `<algorithm>` |

_Change:_

  Effects: ... These operations are atomic read-modify-write operations (6.9.2.2)

_to:_

  Effects: ... Except for `fetch_max` and `fetch_min`, these operations are atomic read-modify-write operations (6.9.2.2). For `fetch_max` and `fetch_min`, if the new value is the same as the existing value, it is unspecified whether or not the new value is written; if it is written, the effect is of a read-modify-write operation.

_Add the following text:_

  `C A::replace_`_key_`(M operand) volatile noexcept;`

  `C A::replace_`_key_`(M operand) noexcept;`

  Requires: These operations are only defined for keys `max` and `min`.

  Effects: `A::fetch_`_key_`(operand)`

  Returns: `std::`_key_`(A::fetch_`_key_`(operand), operand)`

_After `T* operatorop=(T operand) noexcept;` add:_

  These operations are not defined for keys `max` and `min`.

**31.8.5: Partial specialization for pointers [atomics.types.pointer]**

```cpp
namespace std {
  template <class T> struct atomic<T*> {
    ...
    T* fetch_max(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_max(T*, memory_order = memory_order_seq_cst) noexcept;
    T* fetch_min(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_min(T*, memory_order = memory_order_seq_cst) noexcept;
    ...
  };
}
```

_In table 145, [tab:atomic.types.pointer.comp], add the following entries:_

  | Key | Op | Computation |
  |:---:|:--:|:------------|
  | max |    | maximum as computed by |
  |     |    |`std::max` from `<algorithm>` |
  | min |    | minimum as computed by
  |     |    | `std::min` from `<algorithm>` |

_Change:_

  Effects: ... These operations are atomic read-modify-write operations (6.9.2)

_to:_

  Effects: ... These operations are atomic read-modify-write operations, except that for the 'max' and 'min' operations, if the new value is the same as the existing value, it is unspecified whether or not the new value is written.

_Add:_

  `C A::replace_`_key_`(M operand) volatile noexcept;`

  `C A::replace_`_key_`(M operand) noexcept;`

  Requires: These operations are only defined for keys `max` and `min`.

  Effects: `A::fetch_`_key_`(operand)`

  Returns: `std::`_key_`(A::fetch_`_key_`(operand), operand)`

_After `T* operatorop=(T operand) noexcept;` add:_

  These operations are not defined for keys `max` and `min`


# Motivating example

Atomic fetch-and-max can be used to implement a lockfree bounded queue, as explained in [@Gong]:

```c
typedef struct {
  elt item;   /* a queue element */
  int tag;    /* its generation number */
} entry;

typedef struct rep {
  entry elts[SIZE]; /* a bounded array */
  int back;
} reptype;

reptype queue;

void Enq(elt x) {
  int i;
  entry e, *olde;
  e.item = x;                    /* set the new elements item to x */
  i = READ(&(queue.back)) + 1;   /* get a slot in the array for the new element */
  while (true) {
    e.tag = i / SIZE;            /* set the new elements generation number */
    olde = EXCHANGE(&(queue.elts[i % SIZE]), -1, &e);                                   
    /* exchange the new element with slots value if that slot has not been used */
    if (olde->tag == -1) {       /* if exchange is successful */
      break;                     /* get out of the loop */
    }
    ++i;                         /* otherwise, try the next slot */
  }
  FETCH_AND_MAX(&(queue.back), i); /* reset the value of back */
}

elt Deq() {
  entry e, *olde;
  int i, range;
  e.tag = -1;                         /* make e an empty entry */
  e.item = NULL;
  while (true) {                      /* keep trying until an element is found*/
    range = READ(&(queue.back)) - 1;    /* search up to back-1 slots */
    for (i = 0; i <= range; i++) {
      olde = EXCHANGE(&(queue.elts[i % SIZE]), i / SIZE, &e);
      /* check slot to see if it contains the oldest element */
      if (olde->tag != -1) {          /* if so */
        return(olde->item);           /* return the item in it */
      }
    } /* otherwise try the next one */
  }
}
```

---
references:
  - id: Gottlieb
    citation-label: "Gottlieb 1982"
    title: "The NYU Ultracomputer - Designing an MIMD Shared Memory Parallel Computer"
    author:
      - family: Gottlieb
        given: Allan
      - family: Grishman
        given: Ralph
      - family: Kruskal
        given: "Clyde P."
      - family: McAuliffe
        given: "Kevin P."
      - family: Rudolph
        given: Larry
      - family: Snir
        given: Marc
    URL: https://ieeexplore.ieee.org/document/1676201
  - id: Lipovski
    citation-label: "Lipovski 1988"
    title: "A Fetch-And-Op Implementation for Parallel Computers"
    author:
      - family: Lipovski
        given: "G. J."
      - family: Vaughan
        given: Paul
    URL: https://ieeexplore.ieee.org/document/5249
  - id: Kruskal
    citation-label: "Kruskal 1986"
    title: "Efficient Synchronization on Multiprocessors with Shared Memory"
    author:
      - family: Kruskal
        given: "Clyde P."
      - family: Rudolph
        given: Larry
      - family: Snir
        given: Marc
    URL: https://dl.acm.org/doi/10.1145/48022.48024
  - id: Draughon
    citation-label: "Draughon 1967"
    title: "Programming Considerations for Parallel Computers"
    author:
      - family: Draughon
        given: E.
      - family: Grishman
        given: Ralph
      - family: Schwartz
        given: J.
      - family: Stein
        given: A.
    URL: https://nyuscholars.nyu.edu/en/publications/programming-considerations-for-parallel-computers
  - id: P0020
    citation-label: P0020
    title: "P0020r6 : Floating Point Atomic"
    author:
      - family: Edwards
        given: "H. Carter"
      - family: Boehm
        given: Hans
      - family: Giroux
        given: Olivier
      - family: Bastien
        given: JF
      - family: Reus
        given: James
    URL: https://wg21.link/p0020r6
  - id: Gong
    citation-label: "Gong 1990"
    title: "A Library of Concurrent Objects and Their Proofs of Correctness"
    author:
      - family: Gong
        given: Chun
      - family: Wing
        given: "Jeanette M."
    URL: http://www.cs.cmu.edu/~wing/publications/CMU-CS-90-151.pdf
---
